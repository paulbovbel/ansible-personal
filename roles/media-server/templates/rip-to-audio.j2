#!/usr/bin/env bash
#
# Usage: ./rip-to-audio <SOURCE_DIR> <TARGET_DIR>
#
# - Finds all *.mkv in SOURCE_DIR (recursive).
# - Strips patterns like 'HDTV-720p' from the output filename.
# - Tries to copy audio directly (no re-encode).
# - If that fails, re-encode to AAC (VBR).
# - Uses a .partial file to avoid corrupt final output on interruption.
# - Skips files that already have a corresponding .m4a.
# - Prevents ffmpeg from reading stdin (so it doesn't break the find-loop).

set -euo pipefail

if (( $# < 2 )); then
  echo "Usage: $0 <SOURCE_DIR> <TARGET_DIR>"
  exit 1
fi

SOURCE_DIR="$1"
TARGET_DIR="$2"

# Make sure ffmpeg is available
if ! command -v ffmpeg &>/dev/null; then
  echo "Error: ffmpeg not found."
  exit 1
fi

# Remove video-related tags on the file
STRIP_PATTERN='s/\s*HDTV.*//Ig'

# Find all *.mkv files (case-insensitive) and process them one by one.
# We use process substitution (`< <(...)`) so ffmpeg won't consume our loop's stdin.
while IFS= read -r -d '' mkv_file; do
  # 1) Compute the relative path within SOURCE_DIR
  #    e.g.: /path/to/source/sub/Video.HDTV-720p.mkv
  #          => sub/Video.HDTV-720p.mkv
  rel_path="${mkv_file#"$SOURCE_DIR"/}"

  # 2) Strip off .mkv to get the "raw" name; we also want to remove the directory part
  #    so we can apply the sed-based pattern on the filename itself.
  dir_part="$(dirname "$rel_path")"
  base_no_ext="$(basename "${rel_path%.mkv}")"

  # 3) Use sed to remove the 'HDTV-720p' pattern (and minor punctuation around it).
  #    Adjust this as needed for other patterns like "WEB-1080p" or "BluRay.1080p".
  cleaned_name="$(echo "$base_no_ext" | sed -E "$STRIP_PATTERN")"

  # 4) Construct final out_file path, ensuring .m4a extension
  #    e.g.: $TARGET_DIR/sub/Video.m4a
  out_file="$TARGET_DIR/$dir_part/$cleaned_name.m4a"
  partial_file="$out_file.partial"

  # 5) Skip if final output already exists
  if [[ -f "$out_file" ]]; then
    echo "Skipping (already exists): $out_file"
    continue
  fi

  # 6) Remove stale partial file if present
  if [[ -f "$partial_file" ]]; then
    echo "Removing stale partial: $partial_file"
    rm -f "$partial_file"
  fi

  # 7) Create output directory if necessary
  mkdir -p "$(dirname "$out_file")"

  echo "Processing: $mkv_file"
  echo "       to -> $out_file"

  # 8) First, try copying the existing audio track (no re-encode)
  #    -nostdin   => ffmpeg won't read from stdin
  #    -vn        => drop video
  #    -c:a copy  => copy audio bitstream
  #    -f mp4     => produce an MP4 container (m4a is audio-only MP4)
  #    -y         => overwrite partial file if it exists
  set +e  # We'll handle ffmpeg failure manually
  ffmpeg -nostdin \
         -i "$mkv_file" \
         -vn -c:a copy \
         -f mp4 -y \
         "$partial_file"
  ffmpeg_status=$?
  set -e

  if (( ffmpeg_status != 0 )); then
    echo "Audio copy failed (unsupported codec?), re-encoding to AAC VBR..."

    # 9) Fallback: re-encode to AAC VBR
    #    -q:a 2 => a typical VBR quality level (range ~0=best to ~5=lower)
    ffmpeg -nostdin \
           -i "$mkv_file" \
           -vn -c:a aac -q:a 2 \
           -f mp4 -y \
           "$partial_file"
  fi

  # 10) Move partial to final output if successful
  mv "$partial_file" "$out_file"

  echo "Done: $out_file"
  echo

done < <(find "$SOURCE_DIR" -type f \( -iname "*.mkv" -o -iname "*.mp4" -o -iname "*.avi" -o -iname "*.mov" \) -print0)
